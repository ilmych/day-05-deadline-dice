<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Deadline Dice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: #000;
            color: white;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .app {
            min-height: 100vh;
            background: linear-gradient(180deg, #1c1c1e 0%, #000 100%);
            padding: 1rem;
            padding-top: 3rem;
        }

        .header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .header p {
            font-size: 0.95rem;
            color: #8e8e93;
            margin-top: 0.25rem;
        }

        /* Input Section */
        .input-section {
            background: #1c1c1e;
            border-radius: 16px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .input-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            display: block;
        }

        .task-input {
            width: 100%;
            background: #2c2c2e;
            border: none;
            border-radius: 10px;
            padding: 0.875rem 1rem;
            color: #fff;
            font-size: 1rem;
            font-family: inherit;
        }

        .task-input::placeholder {
            color: #48484a;
        }

        .task-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #ff9500;
        }

        /* Timeframe Selector */
        .timeframe-section {
            background: #1c1c1e;
            border-radius: 16px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .timeframe-options {
            display: flex;
            gap: 0.5rem;
        }

        .timeframe-btn {
            flex: 1;
            background: #2c2c2e;
            border: none;
            border-radius: 10px;
            padding: 0.75rem 0.5rem;
            color: #8e8e93;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .timeframe-btn.active {
            background: linear-gradient(135deg, #ff9500 0%, #ff6b00 100%);
            color: #fff;
        }

        /* Dice Section */
        .dice-section {
            background: linear-gradient(135deg, #2c2c2e 0%, #1c1c1e 100%);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 1rem;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
            overflow: hidden;
            z-index: 10;
        }

        .dice-section:active {
            background: linear-gradient(135deg, #3c3c3e 0%, #2c2c2e 100%);
        }

        .dice-container {
            font-size: 4rem;
            margin-bottom: 1rem;
            display: flex;
            gap: 0.5rem;
        }

        .dice {
            display: inline-block;
            transition: transform 0.1s;
        }

        .dice.rolling {
            animation: roll 0.15s ease-in-out infinite;
        }

        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(15deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-15deg) scale(1.1); }
            100% { transform: rotate(0deg) scale(1); }
        }

        .dice-hint {
            color: #8e8e93;
            font-size: 0.95rem;
        }

        .shake-icon {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            opacity: 0.3;
        }

        /* Result Section */
        .result-section {
            background: #1c1c1e;
            border-radius: 16px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            display: none;
        }

        .result-section.active {
            display: block;
        }

        .result-header {
            font-size: 0.8rem;
            font-weight: 600;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 1rem;
        }

        .result-task {
            font-size: 1.1rem;
            color: #fff;
            font-weight: 600;
            margin-bottom: 1rem;
            word-wrap: break-word;
        }

        .result-deadline {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .result-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: #2c2c2e;
            border-radius: 10px;
        }

        .result-icon {
            font-size: 1.25rem;
        }

        .result-value {
            font-size: 1.1rem;
            font-weight: 500;
            color: #fff;
        }

        .result-label {
            font-size: 0.8rem;
            color: #8e8e93;
        }

        /* History Section */
        .history-section {
            background: #1c1c1e;
            border-radius: 16px;
            padding: 1rem;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .history-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .history-clear {
            background: none;
            border: none;
            color: #ff453a;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: #2c2c2e;
            border-radius: 10px;
        }

        .history-task {
            font-size: 0.9rem;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 50%;
        }

        .history-date {
            font-size: 0.85rem;
            color: #ff9500;
            font-weight: 500;
        }

        .empty-history {
            color: #48484a;
            font-size: 0.85rem;
            text-align: center;
            padding: 1rem;
        }

        /* Roll button for tap fallback */
        .roll-btn {
            width: 100%;
            background: linear-gradient(135deg, #ff9500 0%, #ff6b00 100%);
            border: none;
            border-radius: 12px;
            padding: 1rem;
            color: #fff;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 1rem;
            display: none;
        }

        .no-motion .roll-btn {
            display: block;
        }

        .no-motion .dice-hint {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app" id="app">
        <div class="header">
            <h1>Deadline Dice üé≤</h1>
            <p>Shake to decide when to do it</p>
        </div>

        <div class="input-section">
            <label class="input-label">What needs to get done?</label>
            <input type="text" class="task-input" id="taskInput" placeholder="e.g., Finish the report">
        </div>

        <div class="timeframe-section">
            <label class="input-label">When do you need it done?</label>
            <div class="timeframe-options">
                <button class="timeframe-btn active" data-range="today">Today</button>
                <button class="timeframe-btn" data-range="week">This Week</button>
                <button class="timeframe-btn" data-range="month">This Month</button>
            </div>
        </div>

        <div class="dice-section" id="diceSection">
            <div class="dice-container">
                <span class="dice" id="dice1">üé≤</span>
                <span class="dice" id="dice2">üé≤</span>
                <span class="dice" id="dice3">üé≤</span>
            </div>
            <div class="dice-hint" id="diceHint">Shake your phone or tap to roll!</div>
            <div class="shake-icon">üì±</div>
        </div>

        <button class="roll-btn" id="rollBtn">Roll the Dice</button>

        <div class="result-section" id="resultSection">
            <div class="result-header">Your deadline</div>
            <div class="result-task" id="resultTask"></div>
            <div class="result-deadline">
                <div class="result-row">
                    <span class="result-icon">üìÖ</span>
                    <div>
                        <div class="result-value" id="resultDate"></div>
                        <div class="result-label">Date</div>
                    </div>
                </div>
                <div class="result-row">
                    <span class="result-icon">üïê</span>
                    <div>
                        <div class="result-value" id="resultTime"></div>
                        <div class="result-label">Time</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="history-section" id="historySection">
            <div class="history-header">
                <span class="history-title">Recent Rolls</span>
                <button class="history-clear" onclick="clearHistory()">Clear</button>
            </div>
            <div class="history-list" id="historyList">
                <div class="empty-history">No rolls yet</div>
            </div>
        </div>
    </div>

    <script>
        // Capacitor helpers
        const isNative = () => {
            try {
                return window.Capacitor && window.Capacitor.isNativePlatform && window.Capacitor.isNativePlatform();
            } catch (e) {
                return false;
            }
        };

        const Plugins = {
            async haptic(style = 'Medium') {
                if (isNative() && window.Capacitor.Plugins.Haptics) {
                    try {
                        await window.Capacitor.Plugins.Haptics.impact({ style });
                    } catch (e) {}
                }
            }
        };

        // State
        let selectedRange = 'today';
        let isRolling = false;
        let history = JSON.parse(localStorage.getItem('deadline_history') || '[]');
        let lastShakeTime = 0;
        let hasMotion = false;

        // Timeframe buttons
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedRange = btn.dataset.range;
                Plugins.haptic('Light');
            });
        });

        // Shake detection
        let motionPermissionRequested = false;

        async function requestMotionPermission() {
            if (motionPermissionRequested) return;
            motionPermissionRequested = true;

            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceMotionEvent.requestPermission();
                    console.log('Motion permission:', permission);
                    if (permission === 'granted') {
                        enableMotion();
                    }
                } catch (e) {
                    console.log('Motion permission error:', e);
                }
            }
        }

        function initShakeDetection() {
            if (window.DeviceMotionEvent) {
                // iOS 13+ requires permission - will request on first interaction
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    console.log('iOS motion - will request permission on tap');
                } else {
                    // Android/older iOS - just enable
                    enableMotion();
                }
            } else {
                console.log('No DeviceMotionEvent support');
                document.getElementById('app').classList.add('no-motion');
            }
        }

        function enableMotion() {
            if (hasMotion) return;
            hasMotion = true;
            console.log('Motion enabled, listening for shake...');
            window.addEventListener('devicemotion', handleMotion);
        }

        function handleMotion(e) {
            if (isRolling) return;

            const now = Date.now();
            if (now - lastShakeTime < 1000) return; // Cooldown

            const acc = e.accelerationIncludingGravity;
            if (!acc) return;

            const total = Math.abs(acc.x || 0) + Math.abs(acc.y || 0) + Math.abs(acc.z || 0);

            // Threshold for shake detection (lowered for better sensitivity)
            if (total > 25) {
                console.log('Shake detected! Total:', total);
                lastShakeTime = now;
                rollDice();
            }
        }

        // Dice rolling
        async function rollDice() {
            if (isRolling) return;

            const task = document.getElementById('taskInput').value.trim() || 'My task';

            isRolling = true;
            Plugins.haptic('Heavy');

            // Start rolling animation
            const dice = document.querySelectorAll('.dice');
            dice.forEach(d => d.classList.add('rolling'));
            document.getElementById('diceHint').textContent = 'Rolling...';

            // Roll for 1 second
            await new Promise(r => setTimeout(r, 1000));

            // Stop animation
            dice.forEach(d => d.classList.remove('rolling'));

            // Generate deadline
            const deadline = generateDeadline();

            // Haptic feedback
            Plugins.haptic('Heavy');

            // Display result
            showResult(task, deadline);

            // Save to history
            saveToHistory(task, deadline);

            document.getElementById('diceHint').textContent = 'Shake or tap to roll again!';
            isRolling = false;
        }

        function generateDeadline() {
            const now = new Date();
            let targetDate = new Date();

            const businessStartHour = 9;
            const businessEndHour = 18;
            const eveningEndHour = 22; // For "today" after business hours

            switch (selectedRange) {
                case 'today':
                    // Today means TODAY - never roll to tomorrow
                    const currentHour = now.getHours();

                    if (currentHour < businessStartHour) {
                        // Before 9am - pick random business hour
                        targetDate.setHours(randomInt(businessStartHour, businessEndHour - 1));
                    } else if (currentHour < businessEndHour - 1) {
                        // During business hours - pick remaining hours
                        targetDate.setHours(randomInt(currentHour + 1, businessEndHour - 1));
                    } else if (currentHour < eveningEndHour - 1) {
                        // After business hours but before 10pm - pick evening time
                        targetDate.setHours(randomInt(currentHour + 1, eveningEndHour - 1));
                    } else {
                        // Very late - just set to 30 min from now
                        targetDate.setHours(currentHour);
                        targetDate.setMinutes(now.getMinutes() + 30);
                    }
                    break;

                case 'week':
                    // This week = until midnight Sunday (end of current calendar week)
                    // Collect valid weekdays remaining this week
                    const weekdaysRemaining = [];
                    const todayDayOfWeek = now.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
                    const daysUntilSunday = todayDayOfWeek === 0 ? 0 : (7 - todayDayOfWeek);

                    for (let dayOffset = 0; dayOffset <= daysUntilSunday; dayOffset++) {
                        const checkDate = new Date(now);
                        checkDate.setDate(now.getDate() + dayOffset);
                        const checkDay = checkDate.getDay();

                        // Is it a weekday (Mon-Fri)?
                        if (checkDay >= 1 && checkDay <= 5) {
                            if (dayOffset === 0) {
                                // Today - only if business hours remain
                                if (now.getHours() < businessEndHour - 1) {
                                    weekdaysRemaining.push({ offset: 0, minHour: Math.max(now.getHours() + 1, businessStartHour) });
                                }
                            } else {
                                weekdaysRemaining.push({ offset: dayOffset, minHour: businessStartHour });
                            }
                        }
                    }

                    if (weekdaysRemaining.length > 0) {
                        const chosen = weekdaysRemaining[randomInt(0, weekdaysRemaining.length - 1)];
                        targetDate.setDate(now.getDate() + chosen.offset);
                        targetDate.setHours(randomInt(chosen.minHour, businessEndHour - 1));
                    } else {
                        // No weekdays left this week (weekend) - give deadline later today
                        targetDate.setHours(Math.min(now.getHours() + 2, 23));
                    }
                    break;

                case 'month':
                    // This month = until midnight last day of current month
                    const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
                    const daysRemainingInMonth = lastDayOfMonth - now.getDate();

                    // Collect valid weekdays remaining this month
                    const monthWeekdays = [];
                    for (let dayOffset = 0; dayOffset <= daysRemainingInMonth; dayOffset++) {
                        const checkDate = new Date(now);
                        checkDate.setDate(now.getDate() + dayOffset);
                        const checkDay = checkDate.getDay();

                        // Is it a weekday (Mon-Fri)?
                        if (checkDay >= 1 && checkDay <= 5) {
                            if (dayOffset === 0) {
                                // Today - only if business hours remain
                                if (now.getHours() < businessEndHour - 1) {
                                    monthWeekdays.push({ offset: 0, minHour: Math.max(now.getHours() + 1, businessStartHour) });
                                }
                            } else {
                                monthWeekdays.push({ offset: dayOffset, minHour: businessStartHour });
                            }
                        }
                    }

                    if (monthWeekdays.length > 0) {
                        const chosenDay = monthWeekdays[randomInt(0, monthWeekdays.length - 1)];
                        targetDate.setDate(now.getDate() + chosenDay.offset);
                        targetDate.setHours(randomInt(chosenDay.minHour, businessEndHour - 1));
                    } else {
                        // No weekdays left this month - give deadline later today
                        targetDate.setHours(Math.min(now.getHours() + 2, 23));
                    }
                    break;
            }

            // Random minutes (round to 15)
            targetDate.setMinutes([0, 15, 30, 45][randomInt(0, 3)]);
            targetDate.setSeconds(0);

            return targetDate;
        }

        function skipToWeekday(date) {
            const day = date.getDay();
            if (day === 0) date.setDate(date.getDate() + 1); // Sunday -> Monday
            if (day === 6) date.setDate(date.getDate() + 2); // Saturday -> Monday
            return date;
        }

        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function showResult(task, date) {
            document.getElementById('resultTask').textContent = task;

            const dateOptions = { weekday: 'long', month: 'short', day: 'numeric' };
            document.getElementById('resultDate').textContent = date.toLocaleDateString('en-US', dateOptions);

            const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
            document.getElementById('resultTime').textContent = date.toLocaleTimeString('en-US', timeOptions);

            document.getElementById('resultSection').classList.add('active');
        }

        function saveToHistory(task, date) {
            const entry = {
                task,
                date: date.toISOString(),
                displayDate: date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
                displayTime: date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
            };

            history.unshift(entry);
            if (history.length > 5) history.pop();

            localStorage.setItem('deadline_history', JSON.stringify(history));
            renderHistory();
        }

        function renderHistory() {
            const list = document.getElementById('historyList');

            if (history.length === 0) {
                list.innerHTML = '<div class="empty-history">No rolls yet</div>';
                return;
            }

            list.innerHTML = history.map(h => `
                <div class="history-item">
                    <span class="history-task">${escapeHtml(h.task)}</span>
                    <span class="history-date">${h.displayDate} ${h.displayTime}</span>
                </div>
            `).join('');
        }

        function clearHistory() {
            history = [];
            localStorage.setItem('deadline_history', JSON.stringify(history));
            renderHistory();
            Plugins.haptic('Light');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize
        initShakeDetection();
        renderHistory();

        // Tap to roll - use both click and touchend for reliability
        const diceSection = document.getElementById('diceSection');
        const rollBtn = document.getElementById('rollBtn');

        function handleTapRoll(e) {
            e.preventDefault();
            e.stopPropagation();
            // Request motion permission on first tap (iOS requirement)
            if (!hasMotion && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                requestMotionPermission();
            }
            rollDice();
        }

        diceSection.addEventListener('click', handleTapRoll);
        diceSection.addEventListener('touchend', handleTapRoll);
        rollBtn.addEventListener('click', handleTapRoll);
        rollBtn.addEventListener('touchend', handleTapRoll);
    </script>
</body>
</html>
